#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Malware Analysis Module for Pegasus-Suite
# Author: Dr. Muhammad Sobri Maulana, CEH

import os
import sys
import time
import json
import random
import hashlib
import platform
import subprocess
from datetime import datetime
from threading import Thread

# Import from pegabox_imports instead of directly
try:
    from pegabox_imports import input_func, requests, REQUESTS_AVAILABLE, raw_input  # type: ignore
except ImportError:
    # Fallback if pegabox_imports is not available
    try:
        import requests
        REQUESTS_AVAILABLE = True
    except ImportError:
        REQUESTS_AVAILABLE = False
        print("[!] Warning: requests module not available. Some features will be limited.")
        print("[*] Please install it using: pip install requests")
    
    # Handle input_func and raw_input
    if sys.version_info[0] >= 3:
        input_func = input
        raw_input = input
    else:
        input_func = raw_input  # type: ignore
        raw_input = raw_input  # type: ignore

# Import colorama with proper type handling
try:
    from colorama import Fore, Style, init  # type: ignore
    init(autoreset=True)
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False
    # Create dummy colorama classes
    class Fore:
        RED = ''
        GREEN = ''
        YELLOW = ''
        BLUE = ''
        MAGENTA = ''
        CYAN = ''
        WHITE = ''
        RESET = ''
    
    class Style:
        BRIGHT = ''
        RESET_ALL = ''

# Helper functions
def clear_screen():
    """Clear the screen based on the operating system."""
    os.system('cls' if os.name == 'nt' else 'clear')

def create_dir_if_not_exists(directory):
    """Create directory if it doesn't exist."""
    if not os.path.exists(directory):
        os.makedirs(directory)

def calculate_file_hash(file_path, hash_type="sha256"):
    """Calculate the hash of a file."""
    hash_functions = {
        "md5": hashlib.md5(),
        "sha1": hashlib.sha1(),
        "sha256": hashlib.sha256(),
        "sha512": hashlib.sha512()
    }
    
    if hash_type.lower() not in hash_functions:
        hash_type = "sha256"
    
    hash_obj = hash_functions[hash_type.lower()]
    
    try:
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                hash_obj.update(chunk)
        return hash_obj.hexdigest()
    except Exception as e:
        print(f"Error calculating hash: {e}")
        return None

class MalwareAnalysisTools:
    """Collection of malware analysis tools."""
    
    def __init__(self):
        """Initialize the malware analysis tools."""
        self.results_dir = "malware_analysis_results"
        create_dir_if_not_exists(self.results_dir)
        self.vt_api_key = None  # VirusTotal API key (would be set by user)
    
    def set_virustotal_api_key(self, api_key):
        """Set the VirusTotal API key."""
        self.vt_api_key = api_key
        return True
    
    def static_analysis(self, file_path):
        """
        Perform static analysis on a file.
        
        Args:
            file_path (str): Path to the file to analyze
            
        Returns:
            dict: Analysis results
        """
        if not os.path.exists(file_path):
            print(f"[-] File not found: {file_path}")
            return None
        
        print(f"[*] Starting static analysis on: {file_path}")
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        file_name = os.path.basename(file_path)
        file_size = os.path.getsize(file_path)
        
        # Calculate file hashes
        print("[*] Calculating file hashes...")
        md5_hash = calculate_file_hash(file_path, "md5")
        sha1_hash = calculate_file_hash(file_path, "sha1")
        sha256_hash = calculate_file_hash(file_path, "sha256")
        
        print(f"[+] MD5: {md5_hash}")
        print(f"[+] SHA1: {sha1_hash}")
        print(f"[+] SHA256: {sha256_hash}")
        
        # Simulate file header analysis
        print("[*] Analyzing file headers...")
        time.sleep(1)
        
        # Detect file type based on extension (this is a simplified version)
        file_ext = os.path.splitext(file_path)[1].lower()
        file_types = {
            '.exe': 'Windows Executable',
            '.dll': 'Dynamic Link Library',
            '.sys': 'System File',
            '.bat': 'Batch File',
            '.ps1': 'PowerShell Script',
            '.vbs': 'Visual Basic Script',
            '.js': 'JavaScript File',
            '.doc': 'Microsoft Word Document',
            '.docx': 'Microsoft Word Document',
            '.xls': 'Microsoft Excel Spreadsheet',
            '.xlsx': 'Microsoft Excel Spreadsheet',
            '.pdf': 'PDF Document',
            '.elf': 'ELF Executable',
            '.so': 'Shared Object',
            '.apk': 'Android Package',
            '.jar': 'Java Archive',
            '.py': 'Python Script',
            '.sh': 'Shell Script'
        }
        
        file_type = file_types.get(file_ext, 'Unknown')
        print(f"[+] Detected file type: {file_type}")
        
        # Simulate searching for suspicious strings
        print("[*] Searching for suspicious strings...")
        time.sleep(1.5)
        
        suspicious_patterns = [
            "CreateRemoteThread",
            "VirtualAlloc",
            "GetProcAddress",
            "LoadLibrary",
            "URLDownloadToFile",
            "WinExec",
            "ShellExecute",
            "cmd.exe",
            "powershell.exe",
            "WScript.Shell",
            "WSH Shell",
            "exec(",
            "eval(",
            "base64_decode",
            "RegCreateKeyEx",
            "RegSetValueEx",
            "HTTP",
            "Socket",
            "Connect"
        ]
        
        # Simulate found strings based on random choice
        found_strings = []
        for pattern in suspicious_patterns:
            if random.random() < 0.3:  # 30% chance to find each pattern
                found_strings.append({
                    "string": pattern,
                    "offset": hex(random.randint(0, file_size)),
                    "context": f"Function call or string reference to {pattern}"
                })
        
        for string in found_strings:
            print(f"[!] Suspicious string found: {string['string']} at offset {string['offset']}")
        
        # Simulate packed/obfuscated detection
        is_packed = random.random() < 0.4  # 40% chance to be packed
        if is_packed:
            packers = ["UPX", "ASPack", "Themida", "VMProtect", "Enigma", "PECompact", "Custom obfuscation"]
            packer = random.choice(packers)
            print(f"[!] Warning: File may be packed with {packer}")
        else:
            packer = None
            print("[+] No packing detected")
        
        # For executable files, simulate imports and sections analysis
        imports = []
        sections = []
        
        if file_ext in ['.exe', '.dll', '.sys']:
            print("[*] Analyzing PE imports...")
            time.sleep(1)
            
            potential_imports = [
                {"library": "kernel32.dll", "functions": ["VirtualAlloc", "CreateProcess", "ReadProcessMemory"]},
                {"library": "user32.dll", "functions": ["FindWindow", "SetWindowsHookEx", "GetAsyncKeyState"]},
                {"library": "wininet.dll", "functions": ["InternetOpen", "InternetConnect", "HttpOpenRequest"]},
                {"library": "advapi32.dll", "functions": ["RegOpenKeyEx", "CryptEncrypt", "CryptAcquireContext"]},
                {"library": "ws2_32.dll", "functions": ["socket", "connect", "send", "recv"]},
                {"library": "ntdll.dll", "functions": ["NtCreateThreadEx", "NtMapViewOfSection", "NtUnmapViewOfSection"]}
            ]
            
            # Randomly select some imports
            import_count = random.randint(2, len(potential_imports))
            for i in range(import_count):
                lib = potential_imports[i]
                func_count = random.randint(1, len(lib["functions"]))
                selected_funcs = random.sample(lib["functions"], func_count)
                
                imports.append({
                    "library": lib["library"],
                    "functions": selected_funcs
                })
                
                print(f"[+] Imported library: {lib['library']}")
                for func in selected_funcs:
                    print(f"  - {func}")
            
            print("[*] Analyzing PE sections...")
            time.sleep(1)
            
            potential_sections = [
                {".text": {"virtual_size": random.randint(1024, 65536), "entropy": round(random.uniform(5.0, 6.5), 2)}},
                {".data": {"virtual_size": random.randint(1024, 16384), "entropy": round(random.uniform(2.0, 4.5), 2)}},
                {".rdata": {"virtual_size": random.randint(1024, 32768), "entropy": round(random.uniform(3.0, 5.0), 2)}},
                {".rsrc": {"virtual_size": random.randint(1024, 8192), "entropy": round(random.uniform(3.0, 5.0), 2)}},
                {".reloc": {"virtual_size": random.randint(512, 4096), "entropy": round(random.uniform(0.0, 3.0), 2)}}
            ]
            
            # Randomly add a suspicious section with high entropy
            if random.random() < 0.3:
                suspicious_sections = [
                    {".upack": {"virtual_size": random.randint(4096, 65536), "entropy": round(random.uniform(7.0, 7.9), 2)}},
                    {".aspack": {"virtual_size": random.randint(4096, 65536), "entropy": round(random.uniform(7.0, 7.9), 2)}},
                    {".nsp0": {"virtual_size": random.randint(4096, 65536), "entropy": round(random.uniform(7.0, 7.9), 2)}},
                    {".packed": {"virtual_size": random.randint(4096, 65536), "entropy": round(random.uniform(7.0, 7.9), 2)}}
                ]
                potential_sections.append(random.choice(suspicious_sections))
            
            # Add the sections to our results
            for section_dict in potential_sections:
                for name, details in section_dict.items():
                    sections.append({
                        "name": name,
                        "virtual_size": details["virtual_size"],
                        "entropy": details["entropy"]
                    })
                    
                    if details["entropy"] > 7.0:
                        print(f"[!] Suspicious section: {name} (Entropy: {details['entropy']})")
                    else:
                        print(f"[+] Section: {name} (Size: {details['virtual_size']} bytes, Entropy: {details['entropy']})")
        
        # Compile results
        results = {
            "timestamp": timestamp,
            "filename": file_name,
            "filepath": file_path,
            "filesize": file_size,
            "file_type": file_type,
            "hashes": {
                "md5": md5_hash,
                "sha1": sha1_hash,
                "sha256": sha256_hash
            },
            "is_packed": is_packed,
            "packer": packer,
            "suspicious_strings": found_strings
        }
        
        if file_ext in ['.exe', '.dll', '.sys']:
            results["pe_info"] = {
                "imports": imports,
                "sections": sections
            }
        
        # Save results
        clean_filename = ''.join(c if c.isalnum() else '_' for c in file_name)
        filename = f"{self.results_dir}/static_analysis_{clean_filename}_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(results, f, indent=4)
        
        print(f"[+] Static analysis complete. Results saved to {filename}")
        return results
    
    def check_virustotal(self, file_hash):
        """
        Check a file hash against VirusTotal database.
        
        Args:
            file_hash (str): SHA256 or MD5 hash to check
            
        Returns:
            dict: VirusTotal results
        """
        if not self.vt_api_key:
            print("[-] VirusTotal API key not set. Please set your API key first.")
            return None
        
        if not file_hash:
            print("[-] Invalid hash provided")
            return None
        
        print(f"[*] Checking hash {file_hash} on VirusTotal...")
        
        # Simulate VirusTotal API request
        print("[*] Sending request to VirusTotal API...")
        time.sleep(2)
        
        # Simulate VirusTotal response
        # In a real implementation, this would use the actual VirusTotal API
        detection_ratio = random.randint(0, 65)
        total_engines = random.randint(65, 70)
        first_seen = (datetime.datetime.now() - datetime.timedelta(days=random.randint(1, 365))).strftime("%Y-%m-%d %H:%M:%S")
        
        results = {
            "resource": file_hash,
            "permalink": f"https://www.virustotal.com/gui/file/{file_hash}/detection",
            "scan_date": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "positives": detection_ratio,
            "total": total_engines,
            "first_seen": first_seen,
            "scan_results": {}
        }
        
        # Simulate scanner results
        scanners = [
            "Microsoft", "Kaspersky", "Symantec", "McAfee", "ClamAV", 
            "Sophos", "Avast", "ESET-NOD32", "Malwarebytes", "F-Secure", 
            "BitDefender", "Avira", "TrendMicro", "Panda", "AVG"
        ]
        
        for scanner in scanners:
            detected = random.random() < (detection_ratio / total_engines)
            
            if detected:
                malware_types = [
                    "Trojan", "Backdoor", "Worm", "Ransomware", "Spyware", 
                    "Adware", "Dropper", "Exploit", "Downloader", "Rootkit"
                ]
                malware_platforms = ["Win32", "Win64", "Generic", "Multi", "MSIL"]
                malware_names = ["Zeus", "Emotet", "TrickBot", "Dridex", "Lokibot", "Formbook", "AgentTesla", "Remcos", "NjRat", "DarkComet"]
                
                result = {
                    "detected": True,
                    "result": f"{random.choice(malware_types)}.{random.choice(malware_platforms)}.{random.choice(malware_names)}.{chr(65+random.randint(0,25))}"
                }
            else:
                result = {
                    "detected": False,
                    "result": None
                }
            
            results["scan_results"][scanner] = result
        
        if detection_ratio == 0:
            threat_level = "Clean"
            print(f"[+] File is likely clean: 0/{total_engines} detections")
        elif detection_ratio < 3:
            threat_level = "Suspicious"
            print(f"[!] File is suspicious: {detection_ratio}/{total_engines} detections")
        elif detection_ratio < 10:
            threat_level = "Potentially Unwanted"
            print(f"[!] Potentially unwanted program: {detection_ratio}/{total_engines} detections")
        else:
            threat_level = "Malicious"
            print(f"[!] File is likely malicious: {detection_ratio}/{total_engines} detections")
        
        # Show some example detections
        print("\nSample detections:")
        count = 0
        for scanner, data in results["scan_results"].items():
            if data["detected"] and count < 5:
                print(f"  - {scanner}: {data['result']}")
                count += 1
        
        results["threat_level"] = threat_level
        
        # Save results
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/virustotal_{file_hash}_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(results, f, indent=4)
        
        print(f"\n[+] VirusTotal check complete. Results saved to {filename}")
        return results
    
    def dynamic_analysis(self, file_path, duration=30):
        """
        Simulate dynamic analysis of a file in controlled environment.
        
        Args:
            file_path (str): Path to the file to analyze
            duration (int): Duration in seconds to monitor
            
        Returns:
            dict: Analysis results
        """
        if not os.path.exists(file_path):
            print(f"[-] File not found: {file_path}")
            return None
        
        print(f"[*] Starting dynamic analysis on: {file_path}")
        print(f"[*] Analysis duration: {duration} seconds")
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        file_name = os.path.basename(file_path)
        
        # Simulate sandbox environment setup
        print("[*] Setting up sandbox environment...")
        time.sleep(2)
        
        results = {
            "timestamp": timestamp,
            "filename": file_name,
            "filepath": file_path,
            "sandbox_type": "Simulated Sandbox",
            "duration": duration,
            "process_activity": [],
            "file_activity": [],
            "network_activity": [],
            "registry_activity": []
        }
        
        # Simulate running the file
        print("[*] Executing file in sandbox...")
        time.sleep(1)
        
        # Simulate process monitoring
        print("[*] Monitoring process activity...")
        
        if random.random() < 0.8:  # 80% chance to spawn processes
            num_processes = random.randint(1, 5)
            process_names = [
                "cmd.exe", "powershell.exe", "wscript.exe", "cscript.exe", 
                "rundll32.exe", "regsvr32.exe", "svchost.exe", "conhost.exe",
                "explorer.exe", "iexplore.exe", "chrome.exe", "firefox.exe"
            ]
            
            for _ in range(num_processes):
                parent_process = os.path.basename(file_path)
                child_process = random.choice(process_names)
                command_line = f"{child_process} {'-'.join(''.join(chr(random.randint(97, 122)) for _ in range(5)) for _ in range(3))}"
                
                process = {
                    "timestamp": (datetime.datetime.now() + datetime.timedelta(seconds=random.randint(1, duration))).strftime("%Y-%m-%d %H:%M:%S"),
                    "process_name": child_process,
                    "parent_process": parent_process,
                    "command_line": command_line,
                    "pid": random.randint(1000, 9999)
                }
                
                results["process_activity"].append(process)
                print(f"[!] Process spawned: {child_process} (PID: {process['pid']})")
        
        # Simulate file activity
        print("[*] Monitoring file system activity...")
        
        if random.random() < 0.7:  # 70% chance to have file operations
            num_files = random.randint(1, 8)
            system_dirs = [
                "C:\\Windows\\System32", "C:\\Windows\\Temp", 
                "C:\\Users\\Admin\\AppData\\Local\\Temp", 
                "C:\\ProgramData", "C:\\Users\\Admin\\AppData\\Roaming"
            ]
            
            operations = ["Created", "Modified", "Deleted", "Read"]
            
            for _ in range(num_files):
                operation = random.choice(operations)
                target_dir = random.choice(system_dirs)
                file_name = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(8))
                file_ext = random.choice(['.exe', '.dll', '.tmp', '.dat', '.bin', '.txt', '.ps1', '.bat'])
                path = f"{target_dir}\\{file_name}{file_ext}"
                
                file_activity = {
                    "timestamp": (datetime.datetime.now() + datetime.timedelta(seconds=random.randint(1, duration))).strftime("%Y-%m-%d %H:%M:%S"),
                    "operation": operation,
                    "path": path
                }
                
                results["file_activity"].append(file_activity)
                print(f"[!] File {operation.lower()}: {path}")
        
        # Simulate network activity
        print("[*] Monitoring network activity...")
        
        if random.random() < 0.6:  # 60% chance to have network activity
            num_connections = random.randint(1, 5)
            protocols = ["TCP", "UDP", "HTTP", "HTTPS", "DNS"]
            
            for _ in range(num_connections):
                protocol = random.choice(protocols)
                ip = '.'.join(str(random.randint(1, 254)) for _ in range(4))
                port = random.randint(1, 65535)
                
                if protocol in ["HTTP", "HTTPS"]:
                    domains = [
                        "malicious-server.com", "data-exfil.net", "command-control.org",
                        "legitimate-looking-site.com", "cdn.download-server.biz",
                        "api.update-service.info", "secure.payment-portal.co",
                        "analytics.tracking-pixel.net"
                    ]
                    domain = random.choice(domains)
                    url_paths = ["/gate.php", "/config.bin", "/update.php", "/data.php", "/c2/report.php", "/api/v1/connect"]
                    url = f"http{'s' if protocol == 'HTTPS' else ''}://{domain}{random.choice(url_paths)}"
                else:
                    domain = None
                    url = None
                
                connection = {
                    "timestamp": (datetime.datetime.now() + datetime.timedelta(seconds=random.randint(1, duration))).strftime("%Y-%m-%d %H:%M:%S"),
                    "protocol": protocol,
                    "remote_address": ip,
                    "remote_port": port,
                    "domain": domain,
                    "url": url,
                    "direction": random.choice(["Outbound", "Inbound"]),
                    "bytes_sent": random.randint(100, 10000) if random.random() < 0.8 else random.randint(10000, 1000000),
                    "bytes_received": random.randint(100, 10000) if random.random() < 0.8 else random.randint(10000, 1000000)
                }
                
                results["network_activity"].append(connection)
                if domain:
                    print(f"[!] Network connection: {protocol} to {domain} ({ip}:{port})")
                    if "malicious" in domain or "exfil" in domain or "command-control" in domain:
                        print(f"[!!!] WARNING: Potentially malicious domain detected: {domain}")
                else:
                    print(f"[!] Network connection: {protocol} to {ip}:{port}")
        
        # Simulate registry activity (Windows specific)
        if platform.system() == 'Windows' or random.random() < 0.7:  # Simulate Windows registry activity
            print("[*] Monitoring registry activity...")
            
            num_reg_ops = random.randint(0, 10)
            reg_roots = ["HKEY_LOCAL_MACHINE", "HKEY_CURRENT_USER"]
            reg_operations = ["Created", "Modified", "Deleted", "Read"]
            
            reg_keys = [
                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
                "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System",
                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",
                "SYSTEM\\CurrentControlSet\\Services",
                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths"
            ]
            
            for _ in range(num_reg_ops):
                root = random.choice(reg_roots)
                key = random.choice(reg_keys)
                
                if random.random() < 0.5:
                    value_name = random.choice(["Autorun", "Shell", "UpdateService", "Agent", "Helper", "Proxy", "Config", "Driver"])
                else:
                    value_name = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for _ in range(8))
                
                operation = random.choice(reg_operations)
                
                if operation in ["Created", "Modified"]:
                    value_types = ["REG_SZ", "REG_DWORD", "REG_BINARY", "REG_EXPAND_SZ"]
                    value_type = random.choice(value_types)
                    
                    if value_type == "REG_SZ" or value_type == "REG_EXPAND_SZ":
                        if random.random() < 0.6:  # 60% chance for executable paths
                            system_dirs = ["C:\\Windows\\System32", "C:\\Windows\\Temp", "C:\\ProgramData"]
                            value_data = f"{random.choice(system_dirs)}\\{value_name}.exe"
                        else:
                            value_data = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz0123456789') for _ in range(16))
                    elif value_type == "REG_DWORD":
                        value_data = random.randint(0, 4294967295)
                    else:  # REG_BINARY
                        value_data = f"Hex data ({random.randint(8, 256)} bytes)"
                else:
                    value_type = None
                    value_data = None
                
                reg_activity = {
                    "timestamp": (datetime.datetime.now() + datetime.timedelta(seconds=random.randint(1, duration))).strftime("%Y-%m-%d %H:%M:%S"),
                    "operation": operation,
                    "root": root,
                    "key": key,
                    "value_name": value_name,
                    "value_type": value_type,
                    "value_data": value_data
                }
                
                results["registry_activity"].append(reg_activity)
                
                # Print certain high-risk registry operations
                if "Run" in key or "Winlogon" in key or "Services" in key:
                    print(f"[!] Registry {operation.lower()}: {root}\\{key}\\{value_name}")
                    if operation in ["Created", "Modified"] and value_data:
                        print(f"    Value: {value_data}")
        
        # Simulate analysis progress
        for i in range(1, 5):
            print(f"[*] Dynamic analysis in progress... {i*25}%")
            time.sleep(duration/5)
        
        # Generate summary and threat assessment
        suspicious_indicators = 0
        
        # Process indicators
        if len(results["process_activity"]) > 3:
            suspicious_indicators += 1
        for process in results["process_activity"]:
            if any(p in process["process_name"].lower() for p in ["cmd", "powershell", "wscript", "rundll32", "regsvr32"]):
                suspicious_indicators += 1
                break
        
        # File indicators
        for file_op in results["file_activity"]:
            if any(d in file_op["path"].lower() for d in ["\\windows\\", "\\system32\\", "\\temp\\"]) and file_op["operation"] == "Created":
                if any(e in file_op["path"].lower() for e in [".exe", ".dll", ".sys", ".ps1", ".vbs"]):
                    suspicious_indicators += 2
                    break
        
        # Network indicators
        c2_detected = False
        for conn in results["network_activity"]:
            if conn.get("domain") and any(d in str(conn.get("domain")).lower() for d in ["malicious", "exfil", "command-control"]):
                suspicious_indicators += 3
                c2_detected = True
            elif conn.get("bytes_sent", 0) > 100000:  # Large data exfiltration
                suspicious_indicators += 1
        
        # Registry indicators
        for reg_op in results["registry_activity"]:
            if "Run" in reg_op["key"] and reg_op["operation"] in ["Created", "Modified"]:
                suspicious_indicators += 2
                break
        
        # Determine threat level
        if suspicious_indicators == 0:
            threat_level = "No suspicious behavior detected"
        elif suspicious_indicators <= 2:
            threat_level = "Low - Some suspicious behavior"
        elif suspicious_indicators <= 4:
            threat_level = "Medium - Suspicious behavior detected"
        else:
            threat_level = "High - Likely malicious behavior"
        
        # Add additional warning for C2
        if c2_detected:
            threat_level += " - Command & Control communication detected"
        
        results["threat_assessment"] = {
            "suspicious_indicators": suspicious_indicators,
            "threat_level": threat_level
        }
        
        print(f"\n[+] Dynamic analysis complete")
        print(f"[+] Threat assessment: {threat_level}")
        
        # Provide summary
        print("\nSummary of activities:")
        print(f"- Process operations: {len(results['process_activity'])}")
        print(f"- File operations: {len(results['file_activity'])}")
        print(f"- Network connections: {len(results['network_activity'])}")
        print(f"- Registry operations: {len(results['registry_activity'])}")
        
        # Save results
        clean_filename = ''.join(c if c.isalnum() else '_' for c in os.path.basename(file_path))
        filename = f"{self.results_dir}/dynamic_analysis_{clean_filename}_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(results, f, indent=4)
        
        print(f"\n[+] Dynamic analysis complete. Results saved to {filename}")
        return results
    
    def analyze_file_in_sandbox(self, file_path):
        """
        Perform a full sandbox analysis of a file.
        
        Args:
            file_path (str): Path to the file to analyze
            
        Returns:
            dict: Combined analysis results
        """
        if not os.path.exists(file_path):
            print(f"[-] File not found: {file_path}")
            return None
        
        print(f"[*] Starting full sandbox analysis on: {file_path}")
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Run sequential analyses
        static_results = self.static_analysis(file_path)
        
        if static_results and static_results["hashes"]["sha256"]:
            vt_results = self.check_virustotal(static_results["hashes"]["sha256"])
        else:
            vt_results = None
        
        dynamic_results = self.dynamic_analysis(file_path, duration=60)
        
        # Combine results
        sandbox_results = {
            "timestamp": timestamp,
            "filename": os.path.basename(file_path),
            "filepath": file_path,
            "static_analysis": static_results,
            "virustotal": vt_results,
            "dynamic_analysis": dynamic_results
        }
        
        # Determine overall threat level
        threat_levels = []
        
        if static_results and static_results.get("is_packed"):
            threat_levels.append("Suspicious (Packed)")
        
        if vt_results and vt_results.get("threat_level"):
            threat_levels.append(vt_results.get("threat_level"))
        
        if dynamic_results and dynamic_results.get("threat_assessment", {}).get("threat_level"):
            threat_levels.append(dynamic_results.get("threat_assessment", {}).get("threat_level"))
        
        # Determine overall threat
        if "Malicious" in threat_levels or "High" in ' '.join(threat_levels):
            overall_threat = "Malicious - High confidence"
        elif "Medium" in ' '.join(threat_levels) or "Suspicious" in ' '.join(threat_levels) or "Potentially Unwanted" in threat_levels:
            overall_threat = "Suspicious - Medium confidence"
        elif "Low" in ' '.join(threat_levels):
            overall_threat = "Potentially unwanted - Low confidence"
        else:
            overall_threat = "Clean - No significant threats detected"
        
        sandbox_results["overall_threat_assessment"] = overall_threat
        
        print(f"\n[+] Sandbox analysis complete")
        print(f"[+] Overall threat assessment: {overall_threat}")
        
        # Save combined results
        clean_filename = ''.join(c if c.isalnum() else '_' for c in os.path.basename(file_path))
        filename = f"{self.results_dir}/sandbox_full_analysis_{clean_filename}_{timestamp}.json"
        with open(filename, 'w') as f:
            json.dump(sandbox_results, f, indent=4)
        
        print(f"\n[+] Full sandbox analysis complete. Results saved to {filename}")
        return sandbox_results

def run_malware_analysis_tools():
    """Return an instance of the malware analysis tools class."""
    return MalwareAnalysisTools()

def malware_analysis_menu():
    """Display the malware analysis tools menu."""
    clear_screen()
    malware_tools = run_malware_analysis_tools()
    
    while True:
        clear_screen()
        print("\n==== Malware Analysis Tools ====")
        print("1. Static Analysis")
        print("2. Dynamic Analysis")
        print("3. Full Sandbox Analysis")
        print("4. VirusTotal Hash Check")
        print("5. Set VirusTotal API Key")
        print("0. Return to Main Menu")
        
        choice = raw_input("\nSelect an option: ")
        
        if choice == '1':
            file_path = raw_input("Enter the full path to the file to analyze: ")
            if os.path.exists(file_path):
                malware_tools.static_analysis(file_path)
            else:
                print(f"[-] Error: File not found at {file_path}")
            raw_input("\nPress Enter to continue...")
            
        elif choice == '2':
            file_path = raw_input("Enter the full path to the file to analyze: ")
            if os.path.exists(file_path):
                try:
                    duration = int(raw_input("Enter monitoring duration in seconds (default: 30): ") or "30")
                except ValueError:
                    duration = 30
                malware_tools.dynamic_analysis(file_path, duration)
            else:
                print(f"[-] Error: File not found at {file_path}")
            raw_input("\nPress Enter to continue...")
            
        elif choice == '3':
            file_path = raw_input("Enter the full path to the file to analyze: ")
            if os.path.exists(file_path):
                malware_tools.analyze_file_in_sandbox(file_path)
            else:
                print(f"[-] Error: File not found at {file_path}")
            raw_input("\nPress Enter to continue...")
            
        elif choice == '4':
            hash_value = raw_input("Enter file hash (MD5, SHA1, or SHA256): ")
            if hash_value:
                malware_tools.check_virustotal(hash_value)
            else:
                print("[-] Error: No hash value provided")
            raw_input("\nPress Enter to continue...")
            
        elif choice == '5':
            api_key = raw_input("Enter your VirusTotal API key: ")
            if api_key:
                malware_tools.set_virustotal_api_key(api_key)
                print("[+] VirusTotal API key set successfully")
            else:
                print("[-] Error: No API key provided")
            raw_input("\nPress Enter to continue...")
            
        elif choice == '0':
            break
        
        else:
            print("Invalid option. Please try again.")
            time.sleep(1)

if __name__ == "__main__":
    malware_analysis_menu() 